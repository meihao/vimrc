Install
    #apt-get install python-yaml
    #pip install ansible  
    #git clone git://github.com/ansible/ansible.git
    #cd ansible && make install
Configuration
    Configuration file has prority sequence.
        ANSIBLE_CONFIG (enviroment path)
        ansible.cfg (current path)
        .ansible.cfg (home path)
        /etc/ansible/ansible.cfg
    add hosts file for ansible
        group
            [group_name1]
            192.168.2.100
            192.168.2.101
            ...
            [group_name2]
            192.168.85.2
        port
            [group_name3]
            10.88.85.90:2222
            10.88.85.123:3333
            ...
        child
            [child1]
            10.0.0.1:2222
            10.0.0.2:3333
            [child2]
            10.0.2.1:3333
            10.0.3.1

            [vps:children]
            child1
            child2
        reg
            [1:3].xxx.org   #= 1.xxx.org, 2.xxx.org, 3.xxx.org
            [a:c].xxx.org   #= a.xxx.org, b.xxx.org, c.xxx.org

Usage
    pattern
    command 
        ansible <pattern_goes_here> -m <module_name> -a <arguments>
        e.g.
        ansible all -m ping          # it's will ping all server in hosts
        ansible 192.168.85.123 -m ping -u tester      # use tester to ping 192.168.85.123
        ansible group_name3 -m ping -u tester  –sudo -K      # use tester to ping group_name3, -K will need root passwd.
    <pattern_goes_here>
        pattern can be one server IP, domain, or hosts groupname, if you want to use multiple group or ip, use colon ":" to split it.
            ip
            ip1:ip2
            domain1:domain2
            group1
            group1:group2:group3
            all
            *            # * = all
            192.168.1.*
             group1:!grop2           # hosts in group1 but not in group2.    !
            group1:&group2        # hosts exists both  gruop1  and group2.   &
            group1[0]                     # group1 first, like python slice, group1[0:100], the exceed result can't be matched
            ~(web|db).*\.example\.com    # regexp
    Ad-Hoc command.  (temporary command, use -a)
        -a  command, -f concurrency, default value is 5, -m choose module.
        run shell
            ansible all -a "/bin/echo hello"         # print hello
            ansible all -a "/sbin/reboot"  -f   10    --sudo  -K     #reboot
            ansible all -m shell -a 'ls -la ~'
        file 
            ansible all -m copy -a "src=~/project/tests/t.py dest=~"                                  # send file
            ansible all -m file -a "dest=~/.t.py mode=777 owner=tester group=tester"                            # modify file 
            ansible all -m file -a "dest=~/tests mode=755 owner=tester group=tester state=diretory"    # create directory
        install
            ansible v1 -m apt -a "name=python-pip state=present" --sudo -K       # install 
            ansible v1 -m apt -a "name=git state=latest"                #install the latest
            ansible v1 -m apt -a "name=git state=absent" --sudo -K        # uninstall if installed.
        user
            ansible all -m user -a "name=foo password=foo" --sudo -K    #adduser
            ansible all -m user -a "name=foo state=absent" --sudo -K     #deluser
        git
             ansible v1 -m git -a "repo=https://github.com/xxxx/xxx.git dest=~/project-dir version=HEAD" #use https checkout. dest shouldnot be exist at first.
        service
            ansible v1 -m service -a "name=mysql state=started" --sudo -K
            ansible v1 -m service -a "name=mysql state=restarted" --sudo -K
            ansible v1 -m service -a "name=mysql state=stopped" --sudo -K 
playbook YAML syntax
        start — as document
        list start , key: value, the space right near the colon(:) is must.  if colon(:) exists in colon, it should be quoted.
        ansible-playbook test.yaml
            ---
            - hosts: {{ servers }}
            tasks:
            - name: Get latest hyve-stress version in PXE server
            command: yum list hyve-stress | grep hyve-stress | awk '{print $2}'
            - name: Get latest hyve-lnxflash version in PXE server
            command: yum list hyve-lnxflash | grep hyve-lnxflash | awk '{print $2}'
            - name: Get latest hyve-testview version in PXE server
            command: yum list hyve-testview | grep hyve-testview | awk '{print $2}'
            - name: Get latest hyve-pxeboot version in PXE server
            command: yum list hyve-pxeboot | grep hyve-pxeboot | awk '{print $2}'
    variable use jinja grammar
        var    k->v
        var_files  list
        --extra-vars 
        global variable will be in group_vars/all
        local variable will be in group_vars/x
        use ansiable-playbok xxx.yml -vv to print variables.
====================================================================
YAML grammar
    hosts
        [webserver1]
        site01 ansible_ssh_user=root
        site02 ansible_ssh_user=tester
        site03 ansible_ssh_port=7777
        site04
        site05 ansible_ssh_private_key_file=/key/.ssh/id_ras.pub
        site06 ansible_ssh_user=www
        ping module can test network between client and servers.
        -k means use password
        -sudo tell ansible use sudo to run task, if sudo need password, use -k; or add ask_sudo_pass in ansible.cfg
        -a means use parameters, and parameters is always be Key=value
    setup module
        ansible machineName -u root -k -m setup  #Ansible use root to execute setup module on machineName, it can gather server basic information.
        setup module can use facter/ohai module to gather information, and the result will have prefix "facter_" or "ohai_"

    file module/copy module
        ansible MachineName -u root -k -m file -a 'path=/etc/fstab'     # Ansible use file module to get/modify/query file information.
            changed	false/true	if file didn't exist or attribute didn't same as expect, it will be ture

        ansible MachineName -u root -k -m copy -a "src=/etc/fstab dest=/tmp/fstab mode=644 owner=root"    # Ansible use copy module to copy file.
            basic information, msg will return the handle

    command module/creates/removes attribute.为ansible默认模块,不指定-m参数时,默认就是调用command模块,但是不支持<,>,|,and,&等,也不支持管道
        command module didn't have return value. but can use creates/removes to detect command success or not.
        command module can "execute remote command in server, and can use setup module parameters"
        ansible MachineName -m command -a "rm rfv /tmp/fstab removes=/tmp/fstab" # if not exists, will output "MachineName | skipped" or will return "ansibletest | success | rc=0 >>"
        ansible MachineName -m file -a 'path=/tmp/fstab state=absent'  # use ansbile file module to delete file. 
    shell module 在远程命令通过/bin/sh来执行.
        shell module can deal rewrite/pipeline output/background jobs
        ansible machineName -m shell -a '/opt/bin/test.sh > /data/log/test.log creates=/data/log/test.log'
    scripts module 本地写一个脚本在远程服务器上执行
        ansible myservers -m script -a "/opt/app/target.sh"
    raw module
    help
        ansible-doc -l
        ansible-doc file  # get file module help
--------------------------------------------------
# xxx.yml
---
- hosts: local   #hosts中指定
  remote_user: root #如果和当前用户一样, 无须指定
    tasks
     -name: whoami
      copy: src=~/hosts dest=~/hosts.dest #本地拷贝到远端
      notify:   #如果copy执行完后~/hosts.dest文件发生了变化,则字号行
        - clear copy # 调用下面handler
    handlers
        在处理执行tasks后服务器发生变化后可供调用的handler

    handlers:
      - name: clear copy
       shell: 'mv ~/xxxx.test{,.bak}'
--------------------------------------------------
===================================================================
